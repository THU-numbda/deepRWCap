#include <iostream>
#include <chrono>
#include <omp.h>

#include "dielectric_generator.h"

int main(int argc, char **argv) {
    int nthreads = 1;
    int total_size = 100000;
    std::string output_folder = "data/";
    if (argc != 5) {
        std::cout << "Usage: " << argv[0] << " <nthreads> <total_count> <output_folder> <poisson/gradient>" << std::endl;
        return 1;
    }
    
    nthreads = std::stoi(argv[1]);
    total_size = std::stoi(argv[2]);
    output_folder = argv[3];
    std::string solver_type = argv[4];
    
    if (solver_type != "poisson" && solver_type != "gradient") {
        std::cout << "Usage: " << argv[0] << " <nthreads> <total_count> <output_folder> <poisson/gradient>" << std::endl;
        return 1;
    }

    int solve_per_thread = total_size / nthreads;
    std::cout << "nthreads=" << nthreads << ", total_size=" << total_size << std::endl;
    omp_set_dynamic(0);
    omp_set_num_threads(nthreads);

    std::vector<std::string> thread_file_names;
    for (int i = 0; i < nthreads; i++) {
        thread_file_names.push_back(output_folder+"/."+std::to_string(i)+".bin");
    }
    deeprwcap::ggft_solver::solver_code solver_type_code = 
        solver_type == "poisson" ? 
        deeprwcap::ggft_solver::solver_code::GFT : deeprwcap::ggft_solver::solver_code::WVTZ;
    #pragma omp parallel
    {
        int id = omp_get_thread_num();  // Get thread ID
        deeprwcap::ggft_solver solver(thread_file_names[id]);
        solver.set_tolerance(1e-6);
        deeprwcap::dielectric_generator gen(id);
        int nruns = id == nthreads - 1 ? total_size - solve_per_thread * (nthreads - 1) : solve_per_thread;
        double total_time = 0;

        for (int i = 0; i < nruns; i++) {
            gen.random_generate(solver.DIEL, solver.STRUCTURE, 5);
            auto start = std::chrono::high_resolution_clock::now();
            solver.solve(solver_type_code);
            auto end = std::chrono::high_resolution_clock::now();
            if (i % 1000 == 0) 
                std::cout << "[thread " << id << "][" << i << "/" << nruns << ", " << total_time << "s/" <<  total_time/(i+1)*nruns << "s] debug" << std::endl;
            total_time += std::chrono::duration<double>(end - start).count();
        }
        std::cout << "[thread " << id << "] " << total_time / nruns << " s/run" << std::endl;
    }

    // Merge binary files generated by each thread, skipping the first two numbers in each file
    std::string merge_name = output_folder
        +"/" + solver_type + ".bin";
    std::ofstream merged_file(merge_name, std::ios::binary);
    std::cout << "Merge to " << merge_name << std::endl;
    deeprwcap::ggft_solver::real dN = deeprwcap::index::N;
    merged_file.write((char*)&dN, sizeof(deeprwcap::ggft_solver::real));
    deeprwcap::ggft_solver::real dW = deeprwcap::index::block_width;
    merged_file.write((char*)&dW, sizeof(deeprwcap::ggft_solver::real));
    for (const auto& file_name : thread_file_names) {
        std::ifstream thread_file(file_name, std::ios::binary);
        if (thread_file) {
            // Skip the first two numbers (assuming they are of type double)
            thread_file.seekg(2 * sizeof(deeprwcap::ggft_solver::real), std::ios::beg);
            merged_file << thread_file.rdbuf();
            thread_file.close();
        }
        std::remove(file_name.c_str());
    }
    merged_file.close();

    return 0;
}