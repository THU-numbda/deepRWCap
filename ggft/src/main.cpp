#include <iostream>
#include <chrono>
#include <omp.h>

#include "dielectric_generator.h"

int main(int argc, char **argv) {
    int nthreads = 1;
    int total_size = 100000;
    std::string output_folder = "data/";
    if (argc > 1) {
        nthreads = std::stoi(argv[1]);
    }
    if (argc > 2) {
        total_size = std::stoi(argv[2]);
    }
    if (argc > 3) {
        output_folder = argv[3];
    }

    int solve_per_thread = total_size / nthreads;
    std::cout << "nthreads=" << nthreads << ", total_size=" << total_size << std::endl;
    omp_set_dynamic(0);
    omp_set_num_threads(nthreads);

    std::vector<std::string> thread_file_names;
    for (int i = 0; i < nthreads; i++) {
        thread_file_names.push_back(output_folder+"/."+std::to_string(i)+".bin");
    }

    #pragma omp parallel
    {
        int id = omp_get_thread_num();  // Get thread ID
        rwcap::ggft_solver solver(thread_file_names[id]);
        // rwcap::ggft_solver solver;
        solver.set_tolerance(1e-6);
        rwcap::dielectric_generator gen(id);
        int nruns = id == nthreads - 1 ? total_size - solve_per_thread * (nthreads - 1) : solve_per_thread;
        double total_time = 0;

        for (int i = 0; i < nruns; i++) {
            gen.random_generate(solver.DIEL, solver.STRUCTURE, 5);
            // gen.iid_uniform(solver.DIEL);
            // std::cout << solver.solve_count << std::endl;
            auto start = std::chrono::high_resolution_clock::now();
            solver.solve(rwcap::ggft_solver::solver_code::WVTZ);
            auto end = std::chrono::high_resolution_clock::now();
            // if (i == 4914) {
                // solver.solve(rwcap::ggft_solver::solver_code::GFT);
                // std::cout << "[" << i  << "] " << solver.gft << std::endl;
            // }
            if (i % 1000 == 0) 
                std::cout << "[thread " << id << "][" << i << "/" << nruns << ", " << total_time << "s/" <<  total_time/(i+1)*nruns << "s] debug" << std::endl;
            total_time += std::chrono::duration<double>(end - start).count();
        }
        std::cout << "[thread " << id << "] " << total_time / nruns << " s/run" << std::endl;
    }

    // Merge binary files generated by each thread, skipping the first two numbers in each file
    std::string merge_name = output_folder
        +"/gft_"+std::to_string(rwcap::index::N)
        +"_"+std::to_string(rwcap::index::block_width)
        +"_"+std::to_string(1+rwcap::dielectric_generator::MAX_BLOCK_COUNT)
        +".bin";
    std::ofstream merged_file(merge_name, std::ios::binary);
    std::cout << "Merge to " << merge_name << std::endl;
    rwcap::ggft_solver::real dN = rwcap::index::N;
    merged_file.write((char*)&dN, sizeof(rwcap::ggft_solver::real));
    rwcap::ggft_solver::real dW = rwcap::index::block_width;
    merged_file.write((char*)&dW, sizeof(rwcap::ggft_solver::real));
    for (const auto& file_name : thread_file_names) {
        std::ifstream thread_file(file_name, std::ios::binary);
        if (thread_file) {
            // Skip the first two numbers (assuming they are of type double)
            thread_file.seekg(2 * sizeof(rwcap::ggft_solver::real), std::ios::beg);
            merged_file << thread_file.rdbuf();
            thread_file.close();
        }
        std::remove(file_name.c_str());
    }
    merged_file.close();

    return 0;
}